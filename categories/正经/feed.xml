<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>正经 on 林中阴影</title><link>https://blog.heysh.xyz/categories/%E6%AD%A3%E7%BB%8F/</link><description>Recent content in 正经 on 林中阴影</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>&amp;copy;贺叶霜，&lt;a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA&lt;/a></copyright><lastBuildDate>Wed, 21 Jul 2021 18:14:49 +0800</lastBuildDate><atom:link href="https://blog.heysh.xyz/categories/%E6%AD%A3%E7%BB%8F/feed.xml" rel="self" type="application/rss+xml"/><item><title>Python与光学计算，2021</title><link>https://blog.heysh.xyz/2021/07/21/python-for-optics-in-2021/</link><pubDate>Wed, 21 Jul 2021 18:14:49 +0800</pubDate><guid>https://blog.heysh.xyz/2021/07/21/python-for-optics-in-2021/</guid><description>&lt;p>本文是&lt;a href="https://blog.heysh.xyz/2019/08/04/python-for-optics/">2019年同名博文&lt;/a>的更新版本。就像在那里说的，光学计算是一个非常宽泛的话题，把所有的库放在一起，倒是具有一种&lt;ruby>全栈&lt;rp>(&lt;/rp>&lt;rt>full-stack&lt;/rt>&lt;rp>)&lt;/rp>&lt;/ruby>工程师的气质，可是好像很容易造成&lt;em>Stack Overflow&lt;/em>。&lt;/p>
&lt;p>这次，我尝试对这些代码进行简单的分类。因为我不属于&lt;em>光学前端工程师&lt;/em>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，也不属于&lt;em>光学后端工程师&lt;/em>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，而更像是&lt;em>光学系统运维&lt;/em>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，分类得大概并不算准确。&lt;/p>
&lt;h2 id="物理光学演示lightpipes">物理光学演示：LightPipes&lt;/h2>
&lt;figure>&lt;img src="lightpipes.png" width="50%"/>
&lt;/figure>
&lt;p>正像我之前说的那样，我使用&lt;a href="https://github.com/opticspy/lightpipes">opticspy/lightpipes&lt;/a>完成了一部分激光物理过程的模拟，这个库大体上能够满足我当时的要求。但是要注意的是，个人感觉这个库是为了物理实验、教学演示而设计的，揭示原理的部分多于实际计算的部分，而且计算是序列化的。或许把它理解成类似&lt;a href="https://phet.colorado.edu/zh_CN/simulations/filter?subjects=physics&amp;amp;type=html">虚拟物理实验室&lt;/a>更好？&lt;/p>
&lt;p>不过如果能力足够的话，大概能在上面实现一些比较复杂的功能。&lt;del>而且话又说回来，真正有一些严肃需求的人，早就去求助一些商业软件了。&lt;/del>&lt;/p>
&lt;h2 id="光线追迹ray-tracing">光线追迹（Ray Tracing）&lt;/h2>
&lt;p>在上次的博文里，在光线追迹方面，我曾经介绍过&lt;a href="https://github.com/Sterncat/opticspy">Sterncat/opticspy&lt;/a>，&lt;a href="https://github.com/quartiq/rayopt">RayOpt&lt;/a>和&lt;a href="https://github.com/cihologramas/pyoptools">cihologramas/pyoptools&lt;/a>，其中，前两组大概已经停止更新了，反而&lt;a href="https://github.com/cihologramas/pyoptools">pyoptools&lt;/a>看起来处于活跃开发的阶段。另外，这次我还看到了三个新鲜面孔：&lt;a href="https://github.com/mjhoptics/ray-optics">mjhoptics/ray-optics&lt;/a>、&lt;a href="https://salsa.debian.org/mess42/pyrate/">mess42/pyrate&lt;/a>和&lt;a href="https://github.com/bryancole/raypier_optics">bryancole/raypier_optics&lt;/a>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。&lt;/p>
&lt;h3 id="ray-optics">ray-optics&lt;/h3>
&lt;figure>&lt;img src="rayoptics.png"/>&lt;figcaption>
&lt;h4>ray-optics的Qt界面&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;em>序列化&lt;/em>的光线追迹，或成像光学，完成度很高，甚至自带一个类似Zemax的界面。在其&lt;a href="https://ray-optics.readthedocs.io/en/latest/Introduction.html">手册&lt;/a>上提到：&lt;/p>
&lt;blockquote>
&lt;p>Rethink how image forming optical calculations are done absent historical constraints on computer speed and memory.&lt;/p>
&lt;/blockquote>
&lt;p>我学不会光学设计肯定是因为软件历史包袱太重，嗯。&lt;/p>
&lt;h3 id="raypier">Raypier&lt;/h3>
&lt;p>非序列的光学追迹，在几何光学传输的基础上增加了一部分高斯光束和衍射效应，并且可以（通过VTK）生成一些漂亮的三维模型。（之后我一定要想办法成功安装……）&lt;/p>
&lt;p>&lt;a href="https://raypier-optics.readthedocs.io/en/latest/">文档&lt;/a>在这里。&lt;/p>
&lt;h3 id="pyrate">pyrate&lt;/h3>
&lt;figure>&lt;img src="pyrate_in_freecad.png"/>
&lt;/figure>
&lt;p>正在写这篇博文的时候，我发现了这一套&lt;a href="https://salsa.debian.org/mess42/pyrate/">代码&lt;/a>，似乎可以与FreeCAD互动，但是更具体的功能和特性还没有仔细看。毕竟我还没找到文档在哪里……&lt;/p>
&lt;h3 id="pyoptools">pyoptools&lt;/h3>
&lt;p>大概还在紧张地开发之中，等&lt;a href="https://pyoptools.readthedocs.io/en/latest/raytrace.html">文档&lt;/a>写好之后我会再回来看看的。&lt;/p>
&lt;h3 id="另ricktu288ray-opticshttpsgithubcomricktu288ray-optics">另：&lt;a href="https://github.com/ricktu288/ray-optics">ricktu288/ray-optics&lt;/a>&lt;/h3>
&lt;p>当然不是用Python编写的，但是谁不喜欢&lt;a href="https://ricktu288.github.io/ray-optics/">开箱即用&lt;/a>的玩具呢？&lt;/p>
&lt;h3 id="另beam4httpswwwstellarsoftwarecom及其他">另：&lt;a href="https://www.stellarsoftware.com/">Beam4&lt;/a>及其他&lt;/h3>
&lt;p>也许代码就像蘑菇一样，找到一个又有另外两个出来。Beam4是用Java编写的，但看起来成熟度比这里的很多库高得多，比如将要提到的两个。&lt;/p>
&lt;p>我把&lt;a href="https://github.com/GNiendorf/tracepy">tracepy&lt;/a>、&lt;a href="https://github.com/kunguz/odak">odak&lt;/a>和&lt;a href="https://github.com/optcom-org/optcom">optcom&lt;/a>列在这里，只是为了之后不要重新发现它们了。求求你们好好写写文档吧……&lt;/p>
&lt;h2 id="光学设计为望远镜日冕仪准备的python">光学设计：为望远镜/日冕仪准备的Python&lt;/h2>
&lt;p>你想学习怎样设计日冕仪吗？&lt;/p>
&lt;figure>&lt;img src="poppy.png"/>&lt;figcaption>
&lt;h4>詹姆斯·韦伯空间望远镜的光学设计，来自poppy&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>就像所有的专业软件一样，如果你理解了整个物理过程，中间的示意图就并不是那么重要了。这样的库包括：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://github.com/brandondube/prysm">brandondube/prysm&lt;/a> (&lt;a href="https://prysm.readthedocs.io/en/stable/examples/index.html">examples&lt;/a>)&lt;/li>
&lt;li>&lt;a href="https://github.com/spacetelescope/poppy">spacetelescope/poppy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ajeldorado/falco-python">ajeldorado/falco-python&lt;/a>&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/li>
&lt;li>&lt;a href="https://github.com/ehpor/hcipy">ehpor/hcipy&lt;/a> (&lt;a href="https://docs.hcipy.org/dev/tutorials/index.html">examples&lt;/a>)&lt;/li>
&lt;/ol>
&lt;p>等。&lt;/p>
&lt;p>它们大概都能够计算光学系统的点扩散函数（PSF）、调制传递函数（MTF）、点列图之类的，而优化算法似乎欠奉&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>。如果你对上面的一系列名词不大了解的话，建议和我一起补习&lt;a href="http://www.optzmx.com/forum.php?mod=viewthread&amp;amp;tid=1131&amp;amp;highlight=%B9%E2%D1%A7%CF%B5%CD%B3">《光学系统设计》&lt;/a>。&lt;/p>
&lt;figure>&lt;img src="know-everything.jpg"
alt="我逐渐理解一切" width="30%"/>
&lt;/figure>
&lt;p>这些库的对比可以看&lt;a href="https://arxiv.org/abs/1807.07042">这里&lt;/a>。&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>如果你真的想设计日冕仪的话也可以读一读这篇文献，那里对设计方法也有一些介绍。&lt;/p>
&lt;p>就我而言，我比较喜欢&lt;code>HCIPy&lt;/code>，至少这里面还包含一些传递过程的内容，不至于直接跳到结论，和上个部分的库们更加接近一些。&lt;/p>
&lt;h2 id="另一类光线追迹">另一类光线追迹&lt;/h2>
&lt;p>这种的主要目的是为了让自己的文章显得更好看，所以我就直接放两张图：&lt;/p>
&lt;figure>&lt;img src="raysect.png"/>&lt;figcaption>
&lt;h4>Raysect生成的，就好像杂志封面一样&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="inkscape_ray_tracing.png"/>&lt;figcaption>
&lt;h4>光线追迹——用inkscape更简单的画图方式&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;ul>
&lt;li>三维：&lt;a href="https://github.com/raysect/source">Raysect&lt;/a>，或者也可以用Blender+&lt;a href="https://github.com/CodeFHD/OptiCore">OptiCore&lt;/a>+&lt;a href="https://github.com/LuxCoreRender/LuxCore">LuxCore&lt;/a>（&lt;a href="https://www.youtube.com/watch?v=3hln88ukiZI">youtube&lt;/a>）&lt;/li>
&lt;li>二维：&lt;a href="https://github.com/damienBloch/inkscape-raytracing">inkscape-raytracing&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="电磁场级别的仿真">电磁场级别的仿真&lt;/h2>
&lt;p>无论是用EME法求解模式的&lt;a href="https://github.com/demisjohn/CAMFR">CAMFR&lt;/a>，还是用FDTD法计算电磁场的&lt;a href="https://github.com/NanoComp/meep">meep&lt;/a>，都远远超出了我的能力，请有识之士自行判断。&lt;/p>
&lt;h2 id="激光谐振腔的简单计算">激光谐振腔的简单计算&lt;/h2>
&lt;p>&lt;a href="www.rezonator.orion-project.org">rezonator&lt;/a>、&lt;a href="https://github.com/simcav/simcav">simcav/simcav&lt;/a>等，或许过于简单了，可能LightPipes能做的事情还要更多一些。&lt;/p>
&lt;h2 id="大气光谱学">大气光谱学&lt;/h2>
&lt;p>请移步&lt;a href="https://github.com/erwanp/awesome-spectra#atmospheric-spectra">这里&lt;/a>和&lt;a href="https://www.researchgate.net/publication/333046820_Py4CAtS-PYthon_for_Computational_ATmospheric_Spectroscopy">这里&lt;/a>。&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>&lt;img src="pynlo.png" alt="pyNLO">&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/pyNLO/PyNLO">PyNLO&lt;/a>：与非线性光学有关，大概是&lt;code>SNLO&lt;/code>的某种代替品。&lt;/li>
&lt;li>&lt;a href="https://github.com/Jomiri/pyfiberamp">Jomiri/pyfiberamp&lt;/a>：有关光纤激光器的计算。&lt;/li>
&lt;li>&lt;a href="https://github.com/AOtools/soapy">AOtools/soapy&lt;/a>：用于自适应光学过程的模拟，另有一组&lt;a href="https://github.com/AOtools/aotools">用于分析&lt;/a>的库。&lt;/li>
&lt;li>&lt;a href="http://www.gwoptics.org/finesse/">Finesse and PyKat&lt;/a>：为了LIGO设计的语言，用于引力波探测器的光路设计。这次我依旧没有看懂。&lt;/li>
&lt;li>&lt;a href="https://www.aps.anl.gov/Science/Scientific-Software/OASYS">OASYS&lt;/a>：如果X射线也是光的话，那么&lt;a href="https://github.com/oasys-kit/wofry">WOFRY&lt;/a>也是光学计算。&lt;/li>
&lt;li>&lt;a href="https://github.com/scottprahl/laserbeamsize">laserbeamsize&lt;/a>：一个完善的激光光斑直径和$M^2$计算库。&lt;/li>
&lt;/ul>
&lt;p>总之祝大家好运吧。如果有条件的话，还是尽量使用商业软件。Seriously.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>据我了解并不存在前两种职业。而运维在哪里都存在。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>感觉这些既会光学又会Python的人，在起名字方面都没有什么创意。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>A J Eldorado Riggs, Garreth Ruane, Erkin Sidick, Carl Coker, Brian D. Kern, Stuart B. Shaklan, &amp;quot;Fast linearized coronagraph optimizer (FALCO) I: a software toolbox for rapid coronagraphic design and wavefront correction,&amp;quot; Proc. SPIE 10698, Space Telescopes and Instrumentation 2018: Optical, Infrared, and Millimeter Wave, 106982V (9 August 2018); &lt;a href="https://doi.org/10.1117/12.2313812">https://doi.org/10.1117/12.2313812&lt;/a>，&lt;a href="https://core.ac.uk/download/pdf/211386255.pdf">PDF文件&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>如果尝试优化的话，可以看看&lt;a href="https://www.sciencedirect.com/science/article/abs/pii/S0030402618315821">doi:10.1016/j.ijleo.2018.10.073&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>Ruane, G., “Review of high-contrast imaging systems for current and future ground- and space-based telescopes I: coronagraph design methods and optical performance metrics”, in &lt;i>Space Telescopes and Instrumentation 2018: Optical, Infrared, and Millimeter Wave&lt;/i>, 2018, vol. 10698. doi:10.1117/12.2312948.&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Python中光学计算相关的库/Awesome Python for Optics</title><link>https://blog.heysh.xyz/2019/08/04/python-for-optics/</link><pubDate>Sun, 04 Aug 2019 20:03:49 +0800</pubDate><guid>https://blog.heysh.xyz/2019/08/04/python-for-optics/</guid><description>&lt;blockquote>
&lt;p>来自2021-07-24的更新：&lt;/p>
&lt;/blockquote>
&lt;p>本文的2021年版本在&lt;a href="https://blog.heysh.xyz/2021/07/21/python-for-optics-in-2021/">这里&lt;/a>。&lt;/p>
&lt;p>以下是2019年的原文。&lt;/p>
&lt;hr>
&lt;blockquote>
&lt;p>这大概是本博客第一次涉及博主在现实世界中的本职工作，大概算是一个好的开始。&lt;/p>
&lt;/blockquote>
&lt;p>在光学设计及模拟的领域，商业软件，比如Zemax/Code V、LASCAD、GLAD等，提供了较为完整的解决方案，对于较为前沿的领域，国内研究的事实标准是，通过MATLAB自行编写可靠性和可维护性都存在较大问题的脚本。但是，对于一些&lt;del>研究经费不足同时工作量不饱和的&lt;/del>课题组，了解这个古老的学科与当今流行语言的交集，可能也具有一定的意义。&lt;/p>
&lt;p>TL; DR：光学计算是一个很宽泛的话题，针对我的要求，之后我大概会试试&lt;a href="https://github.com/opticspy/lightpipes">LightPipes&lt;/a>.&lt;/p>
&lt;p>以下是我找到的一些库的对比。&lt;/p>
&lt;h2 id="spacetelescopepoppyhttpsgithubcomspacetelescopepoppy">&lt;a href="https://github.com/spacetelescope/poppy">spacetelescope/poppy&lt;/a>&lt;/h2>
&lt;figure>&lt;img src="poppy.png"/>
&lt;/figure>
&lt;p>这个库本身是为詹姆斯·韦伯空间望远镜的模拟而设计的，从其&lt;a href="https://nbviewer.jupyter.org/github/spacetelescope/poppy/blob/master/notebooks/POPPY_tutorial.ipynb">tutorial&lt;/a>也可以看出，这个库的主要目的大概是，在衍射明显的条件下模拟成像过程、计算点扩散函数并分析成像质量，特别是针对天文望远镜领域。&lt;/p>
&lt;p>因为我并不真正 &lt;em>理解&lt;/em> 光学成像，我并没有办法判断该库的潜在用途，不过在激光器设计方面该库可能并不适用。&lt;/p>
&lt;h2 id="sterncatopticspyhttpsgithubcomsterncatopticspy">&lt;a href="https://github.com/Sterncat/opticspy">Sterncat/opticspy&lt;/a>&lt;/h2>
&lt;p>&lt;img src="opticspy.png" alt="opticspy">&lt;/p>
&lt;p>看起来，这个库主要用于镜片设计，类似Zemax/Code V等软件所做的那样。具体上，能够完成光线追迹（但是没说能够优化），利用泽尼克多项式拟合（透镜表面/波前？），并计算镜片表面的干涉条纹。下次如果要计算纯粹干涉方面的内容我可能会尝试一下这个。&lt;/p>
&lt;p>另外，这个库散发着一种爱好者的气息，&lt;code>施工中&lt;/code>标志散落在文档各处。&lt;del>对于这种类型的项目可能还是让企业来做比较合适；可是开源之后又赚不到钱。&lt;/del>&lt;/p>
&lt;h2 id="nanocompmeephttpsgithubcomnanocompmeep">&lt;a href="https://github.com/NanoComp/meep">NanoComp/meep&lt;/a>&lt;/h2>
&lt;p>&lt;img src="meep.png" alt="meep">&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Finite-difference_time-domain_method">FDTD&lt;/a>法计算电磁场。这玩意让我想起了我短暂的研究生岁月，那时我学到一件事……人的能力是有极限的。&lt;/p>
&lt;p>下一个。&lt;/p>
&lt;h2 id="sympyhttpsdocssympyorglatestmodulesphysicsopticsindexhtml">&lt;a href="https://docs.sympy.org/latest/modules/physics/optics/index.html">SymPy&lt;/a>&lt;/h2>
&lt;p>SciPy的一个组成部分，拥有一个光学计算模块，但仅仅在代入公式的水平。嗯，如果只是要算算高斯光的传输矩阵什么的，问题应该不大。&lt;/p>
&lt;h2 id="cihologramaspyoptoolshttpsgithubcomcihologramaspyoptools">&lt;a href="https://github.com/cihologramas/pyoptools">cihologramas/pyoptools&lt;/a>&lt;/h2>
&lt;p>大概也是Ray Trace，大概也是个人作品，而且例子都是用一种我看不懂的语言写的。下一个。&lt;/p>
&lt;h2 id="rezonatorwwwrezonatororion-projectorgsimcavsimcavhttpsgithubcomsimcavsimcav等">&lt;a href="www.rezonator.orion-project.org">rezonator&lt;/a>、&lt;a href="https://github.com/simcav/simcav">simcav/simcav&lt;/a>等&lt;/h2>
&lt;p>Rezonator其实不能算是Python库，不过倒也是免费的，而且做的比另一个程序更完整一些。这两个软件的功能比较类似，仅通过谐振腔传输矩阵计算激光谐振腔特性，对于简单的腔形，可能这个就足够了。&lt;/p>
&lt;h2 id="opticspylightpipeshttpsgithubcomopticspylightpipes">&lt;a href="https://github.com/opticspy/lightpipes">opticspy/lightpipes&lt;/a>&lt;/h2>
&lt;p>&lt;img src="lightpipes.png" alt="lightpipes">&lt;/p>
&lt;p>最后我找到的是这个，它的&lt;a href="http://www.okotech.com/lightpipes">官网&lt;/a>上说，这本来是一个*nix下的C++库，1999年开源，并增加了免费Python接口——听起来很靠谱。
具体上来说，这玩意也包含几何光学和衍射光学的相关内容，而且在它的说明文档里直接体现了&lt;a href="https://github.com/opticspy/Optics/blob/master/GeometricOptics/resonator_geometric_optics.ipynb">高斯光谐振腔矩阵计算&lt;/a>和&lt;a href="https://opticspy.github.io/lightpipes/examples_of_lightpipes_for_python.html#laser-examples">强衍射条件下谐振腔的计算&lt;/a>（虽然我还没有看懂）。&lt;/p>
&lt;p>之后，可能会在这个的基础上对激光器进行一些分析——如果计划没有变更的话。&lt;/p>
&lt;hr>
&lt;blockquote>
&lt;p>来自2019-10-23的更新：&lt;/p>
&lt;/blockquote>
&lt;h2 id="finesse-and-pykathttpwwwgwopticsorgfinesse">&lt;a href="http://www.gwoptics.org/finesse/">Finesse and PyKat&lt;/a>&lt;/h2>
&lt;p>为了LIGO设计的语言，用于引力波探测器的光路设计。Finesse有一种十分简单而复古的语法，而&lt;a href="http://www.gwoptics.org/pykat">PyKat&lt;/a>与其说是它的 &lt;em>封装&lt;/em> ，倒不如说是拿报纸包了一下。&lt;/p>
&lt;p>当然，该程序的功能还是挺强大的，甚至还有一些量子光学的内容&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。如果有人想要尝试的话，可以从&lt;a href="http://www.gwoptics.org/learn/">这里&lt;/a>开始。&lt;/p>
&lt;hr>
&lt;blockquote>
&lt;p>来自2020-6-1的更新：&lt;/p>
&lt;/blockquote>
&lt;h2 id="rayopthttpsgithubcomquartiqrayopt">&lt;a href="https://github.com/quartiq/rayopt">RayOpt&lt;/a>&lt;/h2>
&lt;p>&lt;img src="rayopt.png" alt="rayopt">
&lt;img src="rayopt2.png" alt="rayopt">&lt;/p>
&lt;p>和&lt;a href="#sterncatopticspyhttpsgithubcomsterncatopticspy">opticspy&lt;/a>一样，RayOpt也是一组用于代替Zemax的程序，&lt;strong>看起来&lt;/strong>更不像一个玩具。当然，如果要对这样的库作出一个中肯的评价，我觉得至少还要学习十年左右。所以我只是把它列在这里，并且祝&lt;em>路过的旅行者&lt;/em>好运。&lt;/p>
&lt;p>另外，我下次更新这篇文章的时候，差不多要给它们分分类了。毕竟光学计算是一个很宽泛的话题。&lt;del>我先立一个flag在这里。&lt;/del>&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>比如&lt;a href="http://www.gwoptics.org/finesse/reference/">语法说明&lt;/a>里提到了squeezed vacuum input source。不要问我&lt;a href="https://en.wikipedia.org/wiki/Squeezed_coherent_state">那是什么&lt;/a>。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>幂律分布与Zipf's Law</title><link>https://blog.heysh.xyz/2017/12/16/zipf-law/</link><pubDate>Sat, 16 Dec 2017 20:48:36 +0800</pubDate><guid>https://blog.heysh.xyz/2017/12/16/zipf-law/</guid><description>&lt;p>前几天读了&lt;a href="https://book.douban.com/subject/6749832/">《复杂》&lt;/a>。对复杂学的研究，在人工智能重获热度的今天，似乎获得了新的意义——当然，我们还是不知道炼金术的大锅里面发生了什么。&lt;/p>
&lt;p>幂律分布/Zipf定律/&lt;a href="https://zh.wikipedia.org/wiki/%E5%B8%95%E7%B4%AF%E6%89%98%E6%B3%95%E5%88%99">帕累托法则&lt;/a>/80-20定律/whatever，本质上是同一种东西。这种分布模式和正态分布类似，广泛存在于大自然和人造物的各个角落。一般来说，对于具有：&lt;/p>
&lt;ul>
&lt;li>优先连接性（Preferential attachment）/马太效应
&lt;ul>
&lt;li>“凡有的，还要加给他，叫他有余；没有的，连他所有的也要夺过来。”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>成长性
&lt;ul>
&lt;li>网络的尺度不受客观条件的限制，可以无限增长&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>的网络，其节点连接数较为满足幂律分布。&lt;/p>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=fCn8zs912OE">Youtube上&lt;/a>有个视频对幂律分布讲得很清楚，对其中提到的两个实验，我利用python进行了模拟。模拟中使用的&lt;code>jupyter notebook&lt;/code>文件放在了&lt;a href="https://gist.github.com/heyeshuang/fece5abbd6d1cf826dbaf9c3e76361b7">github gist&lt;/a>上。&lt;/p>
&lt;h2 id="猴子和打字机">猴子和打字机&lt;/h2>
&lt;p>一只猴子（我们叫它Shashi Biya）在打字机上乱敲，它敲二十六个字母和空格概率都相等。那么，咱们能不能看出他的用词习惯？答案是肯定的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#069;font-weight:bold">import&lt;/span> &lt;span style="color:#0cf;font-weight:bold">string&lt;/span>&lt;span style="color:#555">,&lt;/span>&lt;span style="color:#0cf;font-weight:bold">random&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#069;font-weight:bold">from&lt;/span> &lt;span style="color:#0cf;font-weight:bold">collections&lt;/span> &lt;span style="color:#069;font-weight:bold">import&lt;/span> Counter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s&lt;span style="color:#555">=&lt;/span>string&lt;span style="color:#555">.&lt;/span>ascii_lowercase&lt;span style="color:#555">+&lt;/span>&lt;span style="color:#c30">&amp;#34; &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#c30">&amp;#34;abcd &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>monkey&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#c30">&amp;#39;&amp;#39;&lt;/span>&lt;span style="color:#555">.&lt;/span>join(random&lt;span style="color:#555">.&lt;/span>choices(s, k&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#f60">10000000&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>monkey&lt;span style="color:#555">=&lt;/span>[m &lt;span style="color:#069;font-weight:bold">for&lt;/span> m &lt;span style="color:#000;font-weight:bold">in&lt;/span> monkey&lt;span style="color:#555">.&lt;/span>split(&lt;span style="color:#c30">&amp;#34; &amp;#34;&lt;/span>) &lt;span style="color:#069;font-weight:bold">if&lt;/span> m]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c&lt;span style="color:#555">=&lt;/span>Counter(monkey)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>common&lt;span style="color:#555">=&lt;/span>c&lt;span style="color:#555">.&lt;/span>most_common()[:&lt;span style="color:#f60">10000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fre&lt;span style="color:#555">=&lt;/span>[value &lt;span style="color:#069;font-weight:bold">for&lt;/span> (key,value) &lt;span style="color:#000;font-weight:bold">in&lt;/span> common]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>plot(fre)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>xscale(&lt;span style="color:#c30">&amp;#39;log&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>yscale(&lt;span style="color:#c30">&amp;#39;log&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>show()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;figure>&lt;img src="https://blog.heysh.xyz/zipf/output_5_0.png"/>&lt;figcaption>
&lt;h4>阶梯形状可能是由于概率相等&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>我们的这位大文豪颇有古风，喜欢用单字（“a”）胜过长单词（“ffsda”），而且用词比例正符合幂律分布：在双log坐标系下，图像大致是一条直线。这很符合直觉：为了得到任何长度大于1的单词，猴子第二次敲的按钮必须不是空格。&lt;/p>
&lt;p>不要嘲笑我们的前辈，人类的语言也具有相同的性质，虽然概率最高的字是the什么的。并不是Zipf’s law限制了猴子打出十四行诗，这或许是个好消息。&lt;/p>
&lt;h2 id="连接曲别针第一种方法">连接曲别针，第一种方法&lt;/h2>
&lt;p>在墙上钉100个钉子，然后随意把曲别针连在上面。哪个钉子上曲别针越多，下一个曲别针挂在上面的概率就越高。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>l&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#f60">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#366">list&lt;/span>&lt;span style="color:#555">=&lt;/span>np&lt;span style="color:#555">.&lt;/span>ones(l)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#069;font-weight:bold">for&lt;/span> i &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#366">range&lt;/span>(&lt;span style="color:#f60">100000&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#366">sum&lt;/span>(&lt;span style="color:#366">list&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p&lt;span style="color:#555">=&lt;/span>[j&lt;span style="color:#555">/&lt;/span>s &lt;span style="color:#069;font-weight:bold">for&lt;/span> j &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#366">list&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k&lt;span style="color:#555">=&lt;/span>np&lt;span style="color:#555">.&lt;/span>random&lt;span style="color:#555">.&lt;/span>choice(l,&lt;span style="color:#f60">1&lt;/span>, p&lt;span style="color:#555">=&lt;/span>p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#366">list&lt;/span>[k]&lt;span style="color:#555">+=&lt;/span>&lt;span style="color:#f60">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>plot(&lt;span style="color:#366">sorted&lt;/span>(&lt;span style="color:#366">list&lt;/span>,reverse&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#069;font-weight:bold">True&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>xscale(&lt;span style="color:#c30">&amp;#39;log&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>yscale(&lt;span style="color:#c30">&amp;#39;log&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>show() &lt;span style="color:#09f;font-style:italic">#指数分布&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;figure>&lt;img src="https://blog.heysh.xyz/zipf/output_9_0.png"/>&lt;figcaption>
&lt;h4>可惜这只是个指数分布&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>与幂律分布相比，指数分布更加“平缓”，而且在双对数坐标系下也并不是一条直线。&lt;/p>
&lt;h2 id="连接曲别针the-right-way">连接曲别针，the right way&lt;/h2>
&lt;p>现在，我有一把曲别针。我随便拿出两个曲别针，并把它们两个所在的串连接起来。&lt;/p>
&lt;p>假设我对每一个曲别针没有特别的爱好，那么，某个串选中的概率，与串中的曲别针个数正相关。这就是所谓的优先连接性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>tic&lt;span style="color:#555">=&lt;/span>timeit&lt;span style="color:#555">.&lt;/span>default_timer()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>l&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#f60">20000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#366">list&lt;/span>&lt;span style="color:#555">=&lt;/span>[&lt;span style="color:#f60">1&lt;/span>]&lt;span style="color:#555">*&lt;/span>l
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#069;font-weight:bold">while&lt;/span> &lt;span style="color:#366">len&lt;/span>(&lt;span style="color:#366">list&lt;/span>)&lt;span style="color:#555">&amp;gt;&lt;/span>&lt;span style="color:#f60">14000&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#366">sum&lt;/span>(&lt;span style="color:#366">list&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p&lt;span style="color:#555">=&lt;/span>[j&lt;span style="color:#555">/&lt;/span>s &lt;span style="color:#069;font-weight:bold">for&lt;/span> j &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#366">list&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k1&lt;span style="color:#555">=&lt;/span>np&lt;span style="color:#555">.&lt;/span>random&lt;span style="color:#555">.&lt;/span>choice(&lt;span style="color:#366">len&lt;/span>(&lt;span style="color:#366">list&lt;/span>),&lt;span style="color:#f60">1&lt;/span>, p&lt;span style="color:#555">=&lt;/span>p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a1&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#366">list&lt;/span>&lt;span style="color:#555">.&lt;/span>pop(k1[&lt;span style="color:#f60">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#366">sum&lt;/span>(&lt;span style="color:#366">list&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p&lt;span style="color:#555">=&lt;/span>[j&lt;span style="color:#555">/&lt;/span>s &lt;span style="color:#069;font-weight:bold">for&lt;/span> j &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#366">list&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k2&lt;span style="color:#555">=&lt;/span>np&lt;span style="color:#555">.&lt;/span>random&lt;span style="color:#555">.&lt;/span>choice(&lt;span style="color:#366">len&lt;/span>(&lt;span style="color:#366">list&lt;/span>),&lt;span style="color:#f60">1&lt;/span>, p&lt;span style="color:#555">=&lt;/span>p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a2&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#366">list&lt;/span>&lt;span style="color:#555">.&lt;/span>pop(k2[&lt;span style="color:#f60">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#366">list&lt;/span>&lt;span style="color:#555">.&lt;/span>append(a1&lt;span style="color:#555">+&lt;/span>a2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>toc&lt;span style="color:#555">=&lt;/span>timeit&lt;span style="color:#555">.&lt;/span>default_timer()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#366">print&lt;/span>(toc&lt;span style="color:#555">-&lt;/span>tic)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>plot(&lt;span style="color:#366">sorted&lt;/span>(&lt;span style="color:#366">list&lt;/span>,reverse&lt;span style="color:#555">=&lt;/span>&lt;span style="color:#069;font-weight:bold">True&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>xscale(&lt;span style="color:#c30">&amp;#39;log&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>yscale(&lt;span style="color:#c30">&amp;#39;log&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#555">.&lt;/span>show()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://blog.heysh.xyz/zipf/output_13_0.png" alt="png">&lt;/p>
&lt;p>好的，我们得到了 &lt;em>基于曲别针的互联网系统&lt;/em> ——至少可以算是个物联网。在这个网络里，（大概）80%的曲别针在20%的链子中，余下的曲别针散落在另外的地方。我们叫那些链子“曲别针巨头”。随着连接次数越来越多，链子越来越长，分散的曲别针越来越少，这就是“链子中心化”，我们现在互联网的状态。&lt;/p>
&lt;p>当继续这个过程的时候，最终（很快）就只剩下唯一一条长链，这就是我们互联网的末日&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>刘慈欣在还没有现在这么出名的时候，写过一篇叫做《赡养人类》的作品，提到了有关“终产者”的概念。当时，有人评论大刘“不懂政治，也不懂经济”，我十分希望这个人是对的。&lt;/p>
&lt;hr>
&lt;p>2018年4年3日的编辑：&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/ccNUtbywz9JgDI9pj6FJlw">这里&lt;/a>有另一个Zipf's Law的例子，可以看出，其仍然满足马太效应的性质。&lt;del>另外，别人的故事编的还是好啊。&lt;/del>&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>这似乎和&lt;a href="https://act.eff.org/action/protect-the-open-internet-order">Net neutrality&lt;/a>并不是一回事。并没有什么邪恶组织，邪恶的只有系统而已。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item></channel></rss>